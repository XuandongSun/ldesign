from collections import Sequence
from collections.abc import Callable
from datetime import datetime
from pathlib import Path
from typing import Any, Literal, overload, Union, TypedDict

import numpy

Point = complex | tuple[float, float] | Sequence[float]
EndTypes = Literal['flush', 'extended', 'round', 'smooth'] | tuple[float, float] | Callable
JoinTypes = Literal['natural', 'miter', 'bevel', 'round', 'smooth'] | Callable
AnchorType = Literal['n', 's', 'e', 'w', 'o', 'ne', 'nw', 'se', 'sw']
PropertyValueType = str | bytes | int
PropertiesType = list[list[PropertyValueType]]
PolygonType = Union['Polygon', 'FlexPath', 'RobustPath', 'Reference']


class Cell:
    @property
    def labels(self) -> list[Label]: ...

    name: str

    @property
    def paths(self) -> list[FlexPath | RobustPath]: ...

    @property
    def polygons(self) -> list[Polygon]: ...

    properties: PropertiesType = ...

    @property
    def references(self) -> list[Reference]: ...

    def __init__(self, name: str) -> None: ...

    def add(self, *elements: Polygon | FlexPath | RobustPath | Label | Reference) -> Cell: ...

    def area(self, by_spec: bool = False) -> float | dict[tuple[int, int], float]: ...

    def bounding_box(self) -> tuple[tuple[float, float], tuple[float, float]] | None: ...

    def convex_hull(self) -> numpy.ndarray: ...

    def copy(self, name, translation=..., rotation=..., magnification=..., x_reflection=..., deep_copy=...) -> Cell: ...

    def delete_property(self, name) -> Cell: ...

    def dependencies(self, recursive: bool) -> list[Cell | RawCell]: ...

    def filter(self, layers: Sequence[int], types: Sequence[int],
               operation: Literal['and', 'or', 'xor', 'nand', 'nor', 'nxor'], polygons: bool = True, paths: bool = True,
               labels: bool = True) -> Cell: ...

    def flatten(self, apply_repetitions: bool = True) -> Cell: ...

    def get_labels(self, apply_repetitions=..., depth=..., layer=..., texttype=...) -> list: ...

    def get_paths(self, apply_repetitions=..., depth=..., layer=..., datatype=...) -> list: ...

    def get_polygons(self, apply_repetitions=..., include_paths=..., depth=..., layer=..., datatype=...) -> list: ...

    def get_property(self, name) -> list: ...

    def remove(self, *elements) -> Cell: ...

    def set_property(self, name, value) -> Cell: ...

    def write_svg(self, outfile, scaling=..., precision=..., shape_style=..., label_style=..., background=..., pad=...,
                  sort_function=...) -> Cell: ...


class Curve:
    tolerance: float = ...

    def __init__(self, xy: Point, tolerance: float = 0.01) -> None: ...

    def arc(self, radius, initial_angle, final_angle, rotation=...) -> Curve: ...

    def bezier(self, xy, relative=...) -> Curve: ...

    def commands(self, *args) -> Curve: ...

    def cubic(self, xy, relative=...) -> Curve: ...

    def cubic_smooth(self, xy, relative=...) -> Curve: ...

    def horizontal(self, x, relative=...) -> Curve: ...

    def interpolation(self, points, angles=..., tension_in=..., tension_out=..., initial_curl=..., final_curl=...,
                      cycle=..., relative=...) -> Curve: ...

    def parametric(self, curve_function, relative=...) -> Curve: ...

    def points(self) -> numpy.ndarray: ...

    def quadratic(self, xy, relative=...) -> Curve: ...

    def quadratic_smooth(self, xy, relative=...) -> Curve: ...

    def segment(self, xy, relative=...) -> Curve: ...

    def turn(self, radius, angle) -> Curve: ...

    def vertical(self, y, relative=...) -> Curve: ...


class FlexPath:
    @property
    def bend_function(self) -> list[Callable | None]: ...

    @property
    def bend_radius(self) -> list[float]: ...

    @property
    def datatypes(self) -> list[int]: ...

    @property
    def ends(self) -> list[EndTypes]: ...

    @property
    def joins(self) -> list[JoinTypes]: ...

    @property
    def layers(self) -> list[int]: ...

    @property
    def num_paths(self) -> int: ...

    properties: PropertiesType = ...
    repetition: Repetition = ...
    scale_width: bool = ...
    simple_path: bool = ...

    @property
    def size(self) -> int: ...

    tolerance: float = ...

    def __init__(self, points: Point | Sequence[Point], width: float | Sequence[float],
                 offset: float | Sequence[float] = 0,
                 joins: Literal['natural', 'miter', 'bevel', 'round', 'smooth'] | Callable = "natural",
                 ends: Literal['flush', 'extended', 'round', 'smooth'] | tuple[float, float] | Callable = "flush",
                 bend_radius: float | Sequence[float] = 0, bend_function: Callable = None,
                 tolerance: float = 1e-2, simple_path: bool = False, scale_width: bool = True, layer: int = 0,
                 datatype: int = 0) -> None: ...

    def apply_repetition(self) -> list: ...

    def arc(self, radius, initial_angle, final_angle, rotation=..., width=..., offset=...) -> FlexPath: ...

    def bezier(self, xy, width=..., offset=..., relative=...) -> FlexPath: ...

    def commands(self, *args, **kwargs) -> Any: ...

    def copy(self) -> FlexPath: ...

    def cubic(self, xy, width=..., offset=..., relative=...) -> FlexPath: ...

    def cubic_smooth(self, xy, width=..., offset=..., relative=...) -> FlexPath: ...

    def delete_gds_property(self, attr) -> FlexPath: ...

    def delete_property(self, name) -> FlexPath: ...

    def get_gds_property(self, attr) -> str: ...

    def get_property(self, name) -> list: ...

    def horizontal(self, x: float | Sequence[float], width: float | Sequence[float] = None,
                   offset: float | Sequence[float] = None, relative: bool = False) -> FlexPath: ...

    def interpolation(self, points, angles=..., tension_in=..., tension_out=..., initial_curl=..., final_curl=...,
                      cycle=..., width=..., offset=..., relative=...) -> FlexPath: ...

    def mirror(self, p1, p2=...) -> FlexPath: ...

    def offsets(self) -> numpy.ndarray: ...

    def parametric(self, path_function, width=..., offset=..., relative=...) -> FlexPath: ...

    def path_spines(self) -> list: ...

    def quadratic(self, xy, width=..., offset=..., relative=...) -> FlexPath: ...

    def quadratic_smooth(self, xy, width=..., offset=..., relative=...) -> FlexPath: ...

    def rotate(self, angle, center=...) -> FlexPath: ...

    def scale(self, s, center=...) -> FlexPath: ...

    def segment(self, xy, width=..., offset=..., relative=...) -> FlexPath: ...

    def set_bend_function(self, *functions) -> FlexPath: ...

    def set_bend_radius(self, *radii) -> FlexPath: ...

    def set_datatypes(self, *datatypes) -> FlexPath: ...

    def set_ends(self, *ends) -> FlexPath: ...

    def set_gds_property(self, attr, value) -> FlexPath: ...

    def set_joins(self, *joins) -> FlexPath: ...

    def set_layers(self, *layers) -> FlexPath: ...

    def set_property(self, name, value) -> FlexPath: ...

    def spine(self) -> numpy.ndarray: ...

    def to_polygons(self) -> list[Polygon]: ...

    def translate(self, dx: Point, dy: float = None) -> FlexPath: ...

    def turn(self, radius, angle, width=..., offset=...) -> FlexPath: ...

    def vertical(self, y, width=..., offset=..., relative=...) -> FlexPath: ...

    def widths(self) -> numpy.ndarray: ...


class GdsWriter:
    def __init__(self, outfile: str | Path, name: str = "library", unit: float = 1e-6, precision: float = 1e-9,
                 max_points: int = 199, timestamp: datetime = None) -> None: ...

    def close(self) -> None: ...

    def write(self, *cells: Cell) -> GdsWriter: ...


class Label:
    anchor: AnchorType = ...
    layer: int = ...
    magnification: float = ...

    @property
    def origin(self) -> tuple[float, float]: ...

    @origin.setter
    def origin(self, value: Point) -> None: ...

    properties: PropertiesType = ...
    repetition: Repetition = ...
    rotation: float = ...
    text: str = ...
    texttype: int = ...
    x_reflection: bool = ...

    def __init__(self, text: str, origin: Point, anchor: AnchorType = 'o', rotation: float = 0,
                 magnification: float = 1, x_reflection: bool = False, layer: int = 0, texttype: int = 0) -> None: ...

    def apply_repetition(self) -> list[Label]: ...

    def copy(self) -> Label: ...

    def delete_gds_property(self, attr: int) -> Label: ...

    def delete_property(self, name: str) -> Label: ...

    def get_gds_property(self, attr: int) -> str: ...

    def get_property(self, name: str) -> list: ...

    def set_gds_property(self, attr: int, value: str) -> Label: ...

    def set_property(self, name: str, value: PropertyValueType | list[PropertyValueType]) -> Label: ...


class Library:
    @property
    def cells(self) -> list[Cell | RawCell]: ...

    name: str = ...
    precision: float = ...
    properties: PropertiesType = ...
    unit: float = ...

    def __init__(self, name: str = 'library', unit: float = 1e-6, precision: float = 1e-9) -> None: ...

    def add(self, *cells: Cell | RawCell) -> Library: ...

    def delete_property(self, name: str) -> Library: ...

    def get_property(self, name: str) -> list[PropertyValueType] | None: ...

    def layers_and_datatypes(self) -> set[tuple[int, int]]: ...

    def layers_and_texttypes(self) -> set[tuple[int, int]]: ...

    def new_cell(self, name: str) -> Cell: ...

    def remove(self, *cells: Cell | RawCell) -> Library: ...

    def replace(self, *cells: Cell | RawCell) -> Library: ...

    def set_property(self, name: str, value: PropertyValueType | list[PropertyValueType]) -> Library: ...

    def top_level(self) -> list[Cell]: ...

    def write_gds(self, outfile: str | Path, max_points: int = 199, timestamp: datetime = None) -> None: ...

    def write_oas(self, outfile, compression_level=..., detect_rectangles=..., detect_trapezoids=...,
                  circletolerance=..., standard_properties=..., validation=...) -> None: ...


class Polygon:
    datatype: int = ...
    layer: int = ...

    @property
    def points(self) -> list[tuple[float, float]]: ...

    properties: PropertiesType = ...
    repetition: Repetition = ...

    @property
    def size(self) -> int: ...

    def __init__(self, points: Sequence[Point], layer: int = 0, datatype: int = 0) -> None: ...

    def apply_repetition(self) -> list[Polygon]: ...

    def area(self) -> float: ...

    def bounding_box(self) -> tuple: ...

    def contain(self, *args, **kwargs) -> Any: ...

    def contain_all(self, *points) -> bool: ...

    def contain_any(self, *points) -> bool: ...

    def copy(self) -> Polygon: ...

    def delete_gds_property(self, attr) -> Polygon: ...

    def delete_property(self, name) -> Polygon: ...

    def fillet(self, radius, tolerance=...) -> Polygon: ...

    def fracture(self, max_points=..., precision=...) -> list: ...

    def get_gds_property(self, attr) -> str: ...

    def get_property(self, name) -> list: ...

    def mirror(self, p1, p2=...) -> Polygon: ...

    def rotate(self, angle, center=...) -> Polygon: ...

    def scale(self, sx, sy=..., center=...) -> Polygon: ...

    def set_gds_property(self, attr, value) -> Polygon: ...

    def set_property(self, name, value) -> Polygon: ...

    def transform(self, magnification=..., x_reflection=..., rotation=..., translation=..., matrix=...) -> Polygon: ...

    def translate(self, dx, dy=...) -> Polygon: ...


class RawCell:
    @property
    def name(self) -> str: ...

    @property
    def size(self) -> int: ...

    def __init__(self, name: str) -> None: ...

    def dependencies(self, recursive: bool) -> list[RawCell]: ...


class Reference:
    cell: Cell | RawCell | str = ...
    magnification: float = ...

    @property
    def origin(self) -> tuple[float, float]: ...

    @origin.setter
    def origin(self, value: Point) -> None: ...

    properties: PropertiesType = ...
    repetition: Repetition = ...
    rotation: float = ...
    x_reflection: bool = ...

    def __init__(self, cell: Cell | RawCell | str, origin: Point = (0, 0), rotation: float = 0,
                 magnification: float = 1,
                 x_reflection: bool = False, columns: int = 1, rows: int = 1, spacing: Point = None) -> None: ...

    def apply_repetition(self) -> list: ...

    def bounding_box(self) -> tuple: ...

    def convex_hull(self) -> numpy.ndarray: ...

    def copy(self) -> Reference: ...

    def delete_gds_property(self, attr) -> Reference: ...

    def delete_property(self, name) -> Reference: ...

    def get_gds_property(self, attr) -> str: ...

    def get_property(self, name) -> list: ...

    def set_gds_property(self, attr, value) -> Reference: ...

    def set_property(self, name, value) -> Reference: ...


class Repetition:
    @property
    def columns(self) -> int | None: ...

    @property
    def offsets(self) -> numpy.ndarray | None: ...

    @property
    def rows(self) -> int | None: ...

    @property
    def size(self) -> int: ...

    @property
    def spacing(self) -> tuple[float, float] | None: ...

    @property
    def v1(self) -> tuple[float, float] | None: ...

    @property
    def v2(self) -> tuple[float, float] | None: ...

    @property
    def x_offsets(self) -> numpy.ndarray | None: ...

    @property
    def y_offsets(self) -> numpy.ndarray | None: ...

    @overload
    def __init__(self, columns: int, rows: int, spacing: Point) -> None: ...

    @overload
    def __init__(self, columns: int, rows: int, v1: Point, v2: Point) -> None: ...

    @overload
    def __init__(self, offsets: Sequence[Point]) -> None: ...

    @overload
    def __init__(self, x_offsets: Sequence[float]) -> None: ...

    @overload
    def __init__(self, y_offsets: Sequence[float]) -> None: ...

    def get_offsets(self) -> numpy.ndarray: ...


class RobustPath:
    @property
    def datatypes(self) -> list[int]: ...

    @property
    def ends(self) -> list[EndTypes]: ...

    @property
    def layers(self) -> list[int]: ...

    @property
    def num_paths(self) -> int: ...

    properties: PropertiesType = ...
    repetition: Repetition = ...
    scale_width: bool = ...
    simple_path: bool = ...

    @property
    def size(self) -> int: ...

    tolerance: float = ...
    max_evals: int = ...

    def __init__(self, initial_point: Point, width: float | Sequence[float], offset: float | Sequence[float] = 0,
                 ends: EndTypes = "flush", tolerance: float = 1e-2, max_evals: int = 1000, simple_path: bool = False,
                 scale_width: bool = True, layer: int = 0, datatype: int = 0) -> None: ...

    def apply_repetition(self) -> list: ...

    def arc(self, radius, initial_angle, final_angle, rotation=..., width=..., offset=...) -> RobustPath: ...

    def bezier(self, xy, width=..., offset=..., relative=...) -> RobustPath: ...

    def commands(self, *args, **kwargs) -> Any: ...

    def copy(self) -> RobustPath: ...

    def cubic(self, xy, width=..., offset=..., relative=...) -> RobustPath: ...

    def cubic_smooth(self, xy, width=..., offset=..., relative=...) -> RobustPath: ...

    def delete_gds_property(self, attr) -> RobustPath: ...

    def delete_property(self, name) -> RobustPath: ...

    def get_gds_property(self, attr) -> str: ...

    def get_property(self, name) -> list: ...

    def gradient(self, u, from_below=...) -> numpy.ndarray: ...

    def horizontal(self, x, width=..., offset=..., relative=...) -> RobustPath: ...

    def interpolation(self, points, angles=..., tension_in=..., tension_out=..., initial_curl=..., final_curl=...,
                      cycle=..., width=..., offset=..., relative=...) -> RobustPath: ...

    def mirror(self, p1, p2=...) -> RobustPath: ...

    def offsets(self, u, from_below=...) -> numpy.ndarray: ...

    def parametric(self, path_function, path_gradient=..., width=..., offset=..., relative=...) -> RobustPath: ...

    def path_spines(self) -> list: ...

    def position(self, u, from_below=...) -> numpy.ndarray: ...

    def quadratic(self, xy, width=..., offset=..., relative=...) -> RobustPath: ...

    def quadratic_smooth(self, xy, width=..., offset=..., relative=...) -> RobustPath: ...

    def rotate(self, angle, center=...) -> RobustPath: ...

    def scale(self, s, center=...) -> RobustPath: ...

    def segment(self, xy, width=..., offset=..., relative=...) -> RobustPath: ...

    def set_datatypes(self, *datatypes) -> RobustPath: ...

    def set_ends(self, *ends) -> RobustPath: ...

    def set_gds_property(self, attr, value) -> RobustPath: ...

    def set_layers(self, *layers) -> RobustPath: ...

    def set_property(self, name, value) -> RobustPath: ...

    def spine(self) -> numpy.ndarray: ...

    def to_polygons(self) -> list: ...

    def translate(self, dx, dy=...) -> RobustPath: ...

    def turn(self, radius, angle, width=..., offset=...) -> RobustPath: ...

    def vertical(self, y, width=..., offset=..., relative=...) -> RobustPath: ...

    def widths(self, u, from_below=...) -> numpy.ndarray: ...


def all_inside(points: Sequence[Point], polygons: PolygonType | Sequence[PolygonType]) -> bool: ...


def any_inside(points: Sequence[Point], polygons: PolygonType | Sequence[PolygonType]) -> bool: ...


def boolean(operand1: PolygonType | Sequence[PolygonType], operand2: PolygonType | Sequence[PolygonType],
            operation: Literal['or', 'and', 'xor', 'not'], precision: float = 1e-3, layer: int = 0,
            datatype: int = 0) -> list[Polygon]: ...


def contour(data: numpy.ndarray, level: float = 0, length_scale: float = 1, precision: float = 0.01, layer: int = 0,
            datatype: int = 0) -> list[Polygon]: ...


def cross(center: Point, full_size: float, arm_width: float, layer: int = 0, datatype: int = 0) -> Polygon: ...


def ellipse(center: Point, radius: float | Sequence[float], inner_radius: float | Sequence[float] = None,
            initial_angle: float = 0, final_angle: float = 0, tolerance: float = 0.01, layer: int = 0,
            datatype: int = 0) -> Polygon: ...


class GdsInfoDict(TypedDict):
    cell_names: list[str]
    layers_and_datatypes: set[tuple[int, int]]
    layers_and_texttypes: set[tuple[int, int]]
    num_polygons: int
    num_paths: int
    num_references: int
    num_labels: int
    unit: float
    precision: float


def gds_info(infile: str | Path) -> GdsInfoDict: ...


def gds_timestamp(filename: str | Path, timestamp: datetime = None) -> datetime: ...


def gds_units(infile: str | Path) -> tuple[float, float]: ...


def inside(points: Sequence[Point], polygons: PolygonType | Sequence[PolygonType]) -> tuple[bool, ...]: ...


def oas_precision(infile: str | Path) -> float: ...


def oas_validate(infile: str | Path) -> tuple[bool, int]: ...


def offset(polygons: PolygonType | Sequence[PolygonType], distance: float,
           join: Literal['miter', 'bevel', 'round'] = 'miter', tolerance: float = 2, precision: float = 1e-3,
           use_union: bool = False, layer: int = 0, datatype: int = 0) -> list[Polygon]: ...


def racetrack(center: Point, straight_length: float, radius: float, inner_radius: float = 0, vertical: bool = False,
              tolerance: float = 0.01, layer: int = 0,
              datatype: int = 0) -> Polygon: ...


def read_gds(infile: str | Path, unit: float = 0, tolerance: float = 1e-2) -> Library: ...


def read_oas(infile: str | Path, unit: float = 0, tolerance: float = 1e-2) -> Library: ...


def read_rawcells(infile: str | Path) -> dict[str, RawCell]: ...


def rectangle(corner1: Point, corner2: Point, layer: int = ..., datatype: int = ...) -> Polygon: ...


def regular_polygon(center: Point, side_length: float, sides: int, rotation: float = 0, layer: int = 0,
                    datatype: int = 0) -> Polygon: ...


def slice(polygons: PolygonType | Sequence[PolygonType], position: float | Sequence[float], axis: Literal['x', 'y'],
          precision: float = 1e-3) -> list[list[Polygon]]: ...


def text(text: str, size: float, position: Point, vertical: bool = False, layer: int = 0, datatype: int = 0) -> list[
    Polygon]: ...
